Лабораторная 3 – Асинхронность, работа по расписанию, события
Теория
1. Асинхронность
   Асинхронность — это подход к выполнению задач, при котором
   операции не блокируют основной поток выполнения программы. Вместо
   ожидания завершения одной задачи система может начать выполнение других
   задач, а когда первая операция завершится — обработает её результат. Для
   работы с асинхронностью в Spring нужно использовать аннотацию
   @EnableAsync в любом конфигурационном классе. Зачем используется
   асинхронность в Spring:
   • Улучшение масштабируемости (не блокировать поток запросов)
   • Параллельная обработка задач
   • Долгие операции (отправка email, генерация отчётов, интеграция с
   внешними API)
   Для того чтобы метод был асинхронным, нужно по пометить данный
   метод аннотацией @Async. При этом метод должен быть публичным.
   Асинхронный метод не может вызываться из того же класса, в котором
   объявлен. Асинхронный метод должен возвращать void или
   CompletableFuture. По умолчанию Spring создаёт SimpleAsyncTaskExecutor в
   котором для каждой задачи создаётся новый поток, что неэффективно из-за
   отсутствия переиспользования потоков. Для улучшения производительности
   можно настроить свой Executor. Для этого нужно создать бин типа Executor с
   именем “taskExecutor”
   . Тогда Spring возьмёт этот Executor и будет выполнять
   на нём все асинхронные задачи.
2. Работа по расписанию
   В Spring есть встроенная поддержка запуска программ по расписанию.
   Для начала работы с запланированными задачи, необходимо в любом
   конфигурационном классе добавить аннотацию @EnableScheduling. Теперь
   можно создавать запланированные задачи. Для того чтобы задача выполнялась
   по расписанию, над методом задачи должна находится аннотация @Scheduled,
   которая и отвечает за запланированный запуск. У аннотации есть 3 основных
   параметра для настройки простой схемы запуска запланированных задач:
   • fixedDelay – Задержка между завершением предыдущей задачи и запуском
   следующей.
   • fixedRate – Интервал между стартами задач, не зависит от времени
   выполнения.
   • initialDelay – Задержка перед первым запуском.
   Все параметры передаются в формате миллисекунд. Также для формирования
   более сложной политики запуска аннотация поддерживает CRON.
   Рисунок 1 – Формат CRON
   По умолчанию все задачи выполняются в одном потоке, что может быть
   не очень производительно. Для того, чтобы задачи выполнялись в несколько
   потоков, необходимо создать бин с типом TaskScheduler, например можно
   создать ThreadPoolTaskScheduler.
   Рисунок 2 – Пример создания пула потоков для фоновых задач
   Исключения @Scheduled методах не прерывают выполнения
   следующих задач. При помощи ScheduledTaskRegistrar можно задачи по
   расписанию динамически и управлять состоянием этих задач. Для этого
   необходимо внедрить объект ScheduledTaskRegistrar и вызвать метод
   добавления новой запланированной задачи.
3. События
   Spring поддерживает событийную систему. В общую шину событий
   публикуется событие, которое потом обрабатывается всеми
   зарегистрированными обработчиками. Такая система позволяет избавится от
   прямых связей модулей и связать их опосредованно через событийную шину.
   Для создания своего типа события, необходимо создать класс наследующий
   класс ApplicationEvent. Для публикации событий существует класс
   ApplicationEventPublisher, его необходимо внедрить и обратиться к его методу
   publishEvent. Данный метод обратится к текущей реализации
   ApplicationEventMulticaster для рассылки данного события всем необходимым
   обработчикам. Для регистрации обработчика необходимо создать метод с
   аннотацией @EventListener
   Рисунок 2 – Пример создания обработчиков событий
   В настройках по умолчанию, вызов метода publishEvent выполняется
   синхронно, то есть будет ждать завершения обработки во всех обработчиках.
   Если есть обработчики, которые работают долго их следует сделать
   асинхронными, чтобы не блокировать основной поток исполнения. При
   высоких нагрузках следует создать свой ApplicationEventMulticaster в которой
   установить пул потоков, в этом случае обработка задач будет выполняться
   параллельно, а основной поток, публикующий событие, также не будет
   блокироваться.
   Рисунок 2 – Пример создания многопоточного мультакастера
   Практика
1. Создайте конфигурационный класс AsyncConfig и пометьте его
   аннотациями @EnableAsync и @Configuration.
2. Создайте конфигурационный класс SchedulingConfig и пометьте его
   аннотациями @EnableScheduling и @Configuration.
3. Создайте класс EventConfig и пометьте его аннотацией
   @Configuration. Создайте в нём бин типа ApplicationEventMulicaster
   и установите в него пул на 5 потоков.
4. В классе SchedulingConfig создайте бин типа TaskScheduler, в
   который установите пул потоков на 5 потоков.
5. Создайте класс UserRegistrationEvent и унаследуйте его от
   ApplicationEvent. Переопределите super конструктор и добавьте туда
   поле String email.
6. Создайте класс UserRegistrationService и пометьте его аннотацией
   @Service. Создайте метод generateUserRegistration и пометьте его
   аннотацией @Scheduled. Установите задержку в 3 секунды после
   старта, и 1 сек задержку между запусками метода. Данный метод
   должен при помощи Faker генерировать email и публиковать событие
   UserRegistrationEvent через ApplicationEventPublisher.
7. Создайте класс EmailService и пометьте его аннотацией @Service.
   Создайте метод sendUserRegConfirmition(String email). Пометьте
   данный метод аннотацией @Async. Данный метод должен выводить
   сообщение об отправке письма, а перед этим делать задержку на 3
   секунды.
8. Создайте класс UserRegistrationEventHandler и пометьте его
   аннотацией @Component. Создайте в нём метод
   handleUserRegisration(UserRegistrationEvent event) и пометьте его
   аннотацией @EventHandler, в данном методе необходимо обращаться
   к email сервису и передавать туда email из события event.
9. Напишите отдельный тест, в котором проверьте асинхронность
   работы email сервиса.
10. Проверьте работу приложения в целом. Приложите скриншот в
    README.md
11. Ответьте на следующие контрольные вопросы
    a. Синхронность и асинхронность. В чём отличие.
    b. Как работает аннотация @Scheduling. Будет ли работать
    приложение на одних аннотациях @Scheduling.
    c. Принцип работы ApplicationEventMulticaster.
    d. Перечислите основные события ApplicationContext (найти
    самостоятельно).
12. Залейте код проекта и README.md в github.